# Copyright 2020 Observational Health Data Sciences and Informatics
#
# This file is part of CovidVulnerabilityIndex
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Execute the Study
#'
#' @details
#' This function executes the CovidVulnerabilityIndex Study.
#'
#' @param connectionDetails    An object of type \code{connectionDetails} as created using the
#'                             \code{\link[DatabaseConnector]{createConnectionDetails}} function in the
#'                             DatabaseConnector package.
#' @param usePackageCohorts    Whether to use the T and O cohorts in the package
#' @param newTargetCohortId    The cohort id of a new target cohort (must be generated already)
#' @param newOutcomeCohortId   The cohort id of a new outcome (must be generated already)
#' @param newCohortDatabaseSchema Schema name where the new cohorts are stored. Note that for SQL Server,
#'                             this should include both the database and schema name, for example 'cdm_data.dbo'.
#' @param newCohortTable       The name of the table that contains the target population and outcome
#'                             cohorts.
#' @param cdmDatabaseSchema    Schema name where your patient-level data in OMOP CDM format resides.
#'                             Note that for SQL Server, this should include both the database and
#'                             schema name, for example 'cdm_data.dbo'.
#' @param cdmDatabaseName      Shareable name of the database
#' @param cohortDatabaseSchema Schema name where the cohorts and covariates are created. You will need to have
#'                             write priviliges in this schema. Note that for SQL Server, this should
#'                             include both the database and schema name, for example 'cdm_data.dbo'.
#' @param cohortTable          The name of the table that will be created in the work database schema.
#'                             This table will hold the target, outcome and variable cohorts used in this study.
#' @param oracleTempSchema     Should be used in Oracle to specify a schema where the user has write
#'                             priviliges for storing temporary tables.
#' @param sampleSize           How many patients to sample from the target population
#' @param riskWindowStart      The start of the risk window (in days) relative to the startAnchor.
#' @param startAnchor          The anchor point for the start of the risk window. Can be "cohort start" or "cohort end".
#' @param riskWindowEnd        The end of the risk window (in days) relative to the endAnchor parameter
#' @param endAnchor            The anchor point for the end of the risk window. Can be "cohort start" or "cohort end".
#' @param firstExposureOnly    Should only the first exposure per subject be included? Note that this is typically done in the createStudyPopulation function,
#' @param removeSubjectsWithPriorOutcome Remove subjects that have the outcome prior to the risk window start?
#' @param priorOutcomeLookback How many days should we look back when identifying prior outcomes?
#' @param requireTimeAtRisk    Should subject without time at risk be removed?
#' @param minTimeAtRisk        The minimum number of days at risk required to be included
#' @param includeAllOutcomes   (binary) indicating whether to include people with outcomes who are not observed for the whole at risk period
#' @param endDay               The end day relative to index for the custom covariates (default is -1)
#' @param outputFolder         Name of local folder to place results; make sure to use forward slashes
#'                             (/). Do not use a folder on a network drive since this greatly impacts
#'                             performance.
#' @param createCohorts        Create the cohortTable table with the cohorts
#' @param runAnalyses          Run the model development
#' @param viewShiny            View the results as a shiny app
#' @param shinyAnalysisId      The analysisId corresponding to the result you want to view
#' @param packageResults       Should results be packaged for later sharing?
#' @param minCellCount         The minimum number of subjects contributing to a count before it can be included
#'                             in packaged results.
#' @param verbosity            Sets the level of the verbosity. If the log level is at or higher in priority than the logger threshold, a message will print. The levels are:
#'                                         \itemize{
#'                                         \item{DEBUG}{Highest verbosity showing all debug statements}
#'                                         \item{TRACE}{Showing information about start and end of steps}
#'                                         \item{INFO}{Show informative information (Default)}
#'                                         \item{WARN}{Show warning messages}
#'                                         \item{ERROR}{Show error messages}
#'                                         \item{FATAL}{Be silent except for fatal errors}
#'                                         }
#' @param cdmVersion           The version of the common data model
#'
#' @examples
#' \dontrun{
#' connectionDetails <- createConnectionDetails(dbms = "postgresql",
#'                                              user = "joe",
#'                                              password = "secret",
#'                                              server = "myserver")
#'
#' execute(connectionDetails,
#'         cdmDatabaseSchema = "cdm_data",
#'         cdmDatabaseName = 'shareable name of the database'
#'         cohortDatabaseSchema = "study_results",
#'         cohortTable = "cohort",
#'         outcomeId = 1,
#'         oracleTempSchema = NULL,
#'         riskWindowStart = 1,
#'         startAnchor = 'cohort start',
#'         riskWindowEnd = 365,
#'         endAnchor = 'cohort start',
#'         outputFolder = "c:/temp/study_results",
#'         createCohorts = T,
#'         runAnalyses = T,
#'         viewShiny = F,
#'         shinyAnalysisId = 1,
#'         packageResults = F,
#'         minCellCount = 10,
#'         verbosity = "INFO",
#'         cdmVersion = 5)
#' }
#'
#' @export
execute <- function(connectionDetails,
                    usePackageCohorts = T,
                    newTargetCohortId = NULL,
                    newOutcomeCohortId = NULL,
                    newCohortDatabaseSchema = NULL,
                    newCohortTable = NULL,
                    cdmDatabaseSchema,
                    cdmDatabaseName = 'friendly database name',
                    cohortDatabaseSchema = cdmDatabaseSchema,
                    cohortTable = "cohort",
                    oracleTempSchema = cohortDatabaseSchema,
                    sampleSize = NULL,
                    riskWindowStart = 0,
                    startAnchor = 'cohort start',
                    riskWindowEnd = 30,
                    endAnchor = 'cohort start',
                    firstExposureOnly = F,
                    removeSubjectsWithPriorOutcome = F,
                    priorOutcomeLookback = 99999,
                    requireTimeAtRisk = F,
                    minTimeAtRisk = 1,
                    includeAllOutcomes = T,
                    endDay = -1,
                    outputFolder,
                    createCohorts = F,
                    runAnalyses = F,
                    viewShiny = F,
                    shinyAnalysisId = 1,
                    packageResults = F,
					          minCellCount = 10,
                    verbosity = "INFO",
                    cdmVersion = 5) {


  standardCovariates <-  FeatureExtraction::createCovariateSettings(useDemographicsAge= T,
                                                                    useDemographicsGender = T,
                                                                    useVisitConceptCountLongTerm = T,
                                                                    endDays = endDay,
                                                                    excludedCovariateConceptIds = 8532)

  if(usePackageCohorts){
    if(!is.null(newTargetCohortId) | !is.null(newOutcomeCohortId)){
      warning('Input new ids but also said to use package cohorts - new ids will be ignored...')
    }
  }

  if (!file.exists(file.path(outputFolder,cdmDatabaseName)))
    dir.create(file.path(outputFolder,cdmDatabaseName), recursive = TRUE)

  ParallelLogger::addDefaultFileLogger(file.path(outputFolder,cdmDatabaseName, "log.txt"))

  if (createCohorts) {
    ParallelLogger::logInfo("Creating cohorts")
    createCohorts(connectionDetails = connectionDetails,
                  cdmDatabaseSchema = cdmDatabaseSchema,
                  cohortDatabaseSchema = cohortDatabaseSchema,
                  cohortTable = cohortTable,
                  usePackageCohorts = usePackageCohorts,
                  newTargetCohortId = newTargetCohortId,
                  newOutcomeCohortId = newOutcomeCohortId,
                  newCohortDatabaseSchema = newCohortDatabaseSchema,
                  newCohortTable = newCohortTable,
                  oracleTempSchema = oracleTempSchema,
                  outputFolder = file.path(outputFolder, cdmDatabaseName))
  }

  if(runAnalyses){

    if(!usePackageCohorts){
      analysisSettings <- data.frame(analysisId = 4008,
                                     studyStartDate = "",
                                     studyEndDate = "",
                                     cohortId = 1
      )
    } else{
    analysisSettings <- data.frame(analysisId = c(8,1008, 2008, 3008),
                                   studyStartDate = c("","20200101","20200101","20200101"),
                                   studyEndDate =c("","20200531","20200531","20200531"),
                                   cohortId = c(15208,15208,15203,15204)
                                   )
    }


    for(i in 1:nrow(analysisSettings)){

      #getData
      ParallelLogger::logInfo("Extracting data")
      plpData <- getData(connectionDetails = connectionDetails,
                         cdmDatabaseSchema = cdmDatabaseSchema,
                         cdmDatabaseName = cdmDatabaseName,
                         cohortDatabaseSchema = cohortDatabaseSchema,
                         cohortTable = cohortTable,
                         cohortId = analysisSettings$cohortId[i],
                         oracleTempSchema = oracleTempSchema,
                         standardCovariates = standardCovariates,
                         endDay = endDay,
                         firstExposureOnly = firstExposureOnly,
                         sampleSize = sampleSize,
                         cdmVersion = cdmVersion,
                         studyStartDate = analysisSettings$studyStartDate[i],
                         studyEndDate = analysisSettings$studyEndDate[i])


      if(!is.null(plpData)){
        #create pop
        ParallelLogger::logInfo("Creating population")
        population <- tryCatch({ PatientLevelPrediction::createStudyPopulation(plpData = plpData,
                                                                    outcomeId = 15202,
                                                                    riskWindowStart = riskWindowStart,
                                                                    startAnchor = startAnchor,
                                                                    riskWindowEnd = riskWindowEnd,
                                                                    endAnchor = endAnchor,
                                                                    firstExposureOnly = firstExposureOnly,
                                                                    removeSubjectsWithPriorOutcome = removeSubjectsWithPriorOutcome,
                                                                    priorOutcomeLookback = priorOutcomeLookback,
                                                                    requireTimeAtRisk = requireTimeAtRisk,
                                                                    minTimeAtRisk = minTimeAtRisk,
                                                                    includeAllOutcomes = includeAllOutcomes)  },                                                     
               finally= ParallelLogger::logTrace('Done pop.'), 
               error= function(cond){ParallelLogger::logTrace(paste0('Error with pop:',cond));return(NULL)})
  
  if(!is.null(population)){


        # apply the model:
        plpModel <- list(model = getModel(),
                         analysisId = paste0("Analysis_",analysisSettings$analysisId[i]),
                         hyperParamSearch = NULL,
                         index = NULL,
                         trainCVAuc = NULL,
                         modelSettings = list(model = 'score', modelParameters = NULL),
                         metaData = NULL,
                         populationSettings = attr(population, "metaData"),
                         trainingTime = NULL,
                         varImp = NULL,
                         dense = T,
                         cohortId = analysisSettings$cohortId[i],
                         outcomeId = 15202,
                         covariateMap = NULL,
                         predict = predictExisting
        )
        class(plpModel) <- 'plpModel'
        ParallelLogger::logInfo("Applying and evaluating model")
        result <- PatientLevelPrediction::applyModel(population = population,
                                                     plpData = plpData,
                                                     plpModel = plpModel)

        result$inputSetting$database <- cdmDatabaseName
        result$executionSummary  <- list()
        result$model <- plpModel
        result$analysisRef <- list()
        result$covariateSummary <- PatientLevelPrediction:::covariateSummary(plpData = plpData, population = population)

        result$covariateSummary <- merge(result$covariateSummary, result$model$model[,c('covariateId', 'points')], by ='covariateId')
        result$covariateSummary$covariateValue = result$covariateSummary$points

        if(!dir.exists(file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",analysisSettings$analysisId[i])))){
          dir.create(file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",analysisSettings$analysisId[i])))
        }
        ParallelLogger::logInfo("Saving results")
        saveRDS(result, file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",analysisSettings$analysisId[i]),'validationResult.rds'))
        ParallelLogger::logInfo(paste0("Results saved to:",file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",analysisSettings$analysisId[i]),'validationResult.rds')))
      }
    }
  }
	  }

  # [TODO] add create shiny app
  viewer <- TRUE
  if(viewShiny) {
    if(file.exists(file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",shinyAnalysisId),'validationResult.rds'))){
      result <- readRDS(file.path(outputFolder,cdmDatabaseName,paste0("Analysis_",shinyAnalysisId),'validationResult.rds'))
      viewer <- PatientLevelPrediction::viewPlp(result)
    } else{
      warning('No results to view...')
    }
  }

  if (packageResults) {
    ParallelLogger::logInfo("Packaging results")


    saveLoc <- file.path(outputFolder,cdmDatabaseName,'export')

    analyses <- dir(file.path(outputFolder,cdmDatabaseName))
    analyses <- analyses[grep('Analysis_',analyses)]

    if(length(analyses)>0){

      for(aid in analyses){
        resultLocation <- file.path(outputFolder,cdmDatabaseName,aid,'validationResult.rds')

        if(file.exists(resultLocation)){
          result <- readRDS(resultLocation)
          result$model$predict <- NULL
          result <- PatientLevelPrediction::transportPlp(plpResult = result,
                                                         save = F,
                                                         n = minCellCount,
                                                         modelName = 'Covid Vul Index',
                                                         dataName = cdmDatabaseName)
          if(!dir.exists(saveLoc)){
            dir.create(saveLoc, recursive = T)
          }
          if(!dir.exists(file.path(saveLoc,aid))){
            dir.create(file.path(saveLoc,aid), recursive = T)
          }
          saveRDS(result, file.path(saveLoc,aid,'validationResult.rds'))

        }
      }

      zipName <- file.path(outputFolder,paste0(cdmDatabaseName, '.zip'))
      OhdsiSharing::compressFolder(saveLoc, zipName)
      # delete temp folder
      unlink(saveLoc, recursive = T)

      writeLines(paste("\nStudy results are compressed and ready for sharing at:", zipName))
    }
  }


  return(viewer)
}




